フォーマット文字列としてユーザが制御可能なバッファを指定した際の脆弱性を実験します
主にリターンアドレスやデストラクタに格納されている関数ポインタを書き換えることを目的とします

32bit用のコードではprintfがargv[1]をそのままフォーマット文字列として使用されている部分に脆弱性があります
よって、プログラムに送り込む悪意ある文字列は「./プログラム名 悪意ある文字列」といった風に指定することになりますが、この文字列に含むことができる文字には制約があります。
例えば、bashといったシェルは古いUNIX時代の互換により、0x00を文字列の終端として認識します
また、bashに限らず多くのシェルでは0x09、0x0a、0x20といった空白や改行を意味する文字を引数の区切りだと認識します
これらの理由により、argvに渡す文字列には0x00、0x09、0x20、0x0aは含んでいてはいけません
実際に攻撃する際には、32bitでは「書き込み先のアドレス」+「書き込み先のアドレス + 2」+「%?????x」+「%???$hn」+「%?????x」+「%???$hn」といった文字列で攻撃を行うと安定します

64bit用のコードではアドレスの上位2byteに0x00(ナル文字)が含まれており、0x00をargvに含ませることはできないため、argvを利用した攻撃は非常に難しくなります
なので今回は少し妥協して、文字列の入力を引数ではなく、gets系関数を利用するようにプログラムを変更しています
これによって、ナル文字を含む文字列をプログラムに引き渡すことができます

では、gets系関数を使用する際に使用できない文字コードは何でしょうか？
gets系関数のリファレンスを見てみると、改行とEOFで文字列の終端を認識するようです
では、0x0aや0xffが使用できないということになりそうです
しかし、実際には0x0aは使用できないものの、0xffは問題なく使用できます
理由は次のgets系関数を模したコードを見るとわかります
fdは読み込みたいファイルディスクリプタであり、stringは呼び出し元から渡したバッファになっています

  while (read(fd, &c, 1) != 0){    // EOF
    string[index++] = c;
    if(c == '\n') break;           // 0x0a
  }

ファイルから読み込まれた文字が0x0aであった場合、ループをbreakして抜けています
これにより、0x0aの後に続いている文字列がバッファに読み込まれなくなってしまうので0x0aは使用することが難しいです
しかし、EOFについてはreadからの戻り値で判定しているのがわかります
実はEOFは文字ではなく、カーネルからの情報なのです
つまり、読み込まれた文字がEOFと等しいビット列を持つかどうかは問題ではないということになります
なので、gets系関数を攻撃する際は安心して0xffといったバイナリを埋め込むことができます
結論として、gets系関数を利用して攻撃を行う際に気をつける文字コードは0x0aのみということになり、argvを利用する場合に比べて攻撃が行いやすくなります

それでは実際にプログラムに入力する悪意ある文字列を見てみましょう
64bitではアドレスに0x00が含まれ、printfはこの文字を終端と認識してしまうため、アドレスを持っている文字は他の文字の後に配置しないといけません
例えば「%?????x」+「%???$hn」+「%?????x」+「%???$hn」+「%?????x」+「%???$hn」+「%?????x」+「%???$hn」+「書き込み先のアドレス」+「書き込み先のアドレス + 2」+「書き込み先のアドレス + 4」+「書き込み先のアドレス + 6」といった文字列で攻撃を行うと安定します

しかし、実はまだ気をつけなければいけないことがあります
パイプを用いてプログラムに標準入力を渡した場合、(例えば)リターンアドレスをシェルコードのアドレスで書き換えてシェルが開いたとしても、シェルがすぐに閉じてしまいます
これを防ぐためには、まず入力したい文字列をテキストファイルに保存した後、ハイフン付きcatコマンドにそのテキストファイルを指定して、さらにその出力をパイプでターゲットプログラムに渡す必要があります(cat text - | ./target)
catコマンドにハイフンを記述することでテキストファイルをパイプに流し込んだ後、ターゲットプログラムがシェルによる標準入力からのデータを続けて受け付けるようになります
